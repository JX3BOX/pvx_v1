{"version":3,"sources":["webpack:///./node_modules/@jx3box/jx3box-facedat/src/Upload.vue?0aea","webpack:///./node_modules/ini/ini.js","webpack:///./node_modules/@jx3box/jx3box-facedat/src/Upload.vue","webpack:///./node_modules/@jx3box/jx3box-facedat/src/FaceINIConverter.js","webpack:///./node_modules/@jx3box/jx3box-facedat/src/DataRouter.js","webpack:///node_modules/@jx3box/jx3box-facedat/src/Upload.vue","webpack:///./node_modules/@jx3box/jx3box-facedat/src/Upload.vue?8ad8","webpack:///./node_modules/@jx3box/jx3box-facedat/src/Upload.vue?55fa","webpack:///./node_modules/lua-json/index.js","webpack:///./node_modules/lua-json/node_modules/luaparse/luaparse.js"],"names":["hasOwnProperty","Object","prototype","eol","process","platform","encode","obj","opt","children","out","section","whitespace","create","separator","k","keys","val","Array","isArray","item","safe","push","length","nk","dotSplit","join","child","str","replace","split","map","part","decode","p","re","lines","line","match","undefined","unsafe","keyRaw","slice","key","valueRaw","value","JSON","parse","call","remove","parts","l","pop","nl","del","isQuoted","charAt","trim","stringify","doUnesc","esc","unesc","i","c","indexOf","substr","_","module","exports","render","_vm","this","_c","_self","staticClass","support","done","attrs","on","resetData","_v","filename","uploadData","selectData","_s","btnText","type","_e","staticRenderFns","getFaceProperty","ini","defaultValue","parseInt","getDecalSection","sectionName","content","parseFloat","convertFaceIni","load","buf","payload","KData","lua","unserialize","console","log","get","data","face","name","props","String","default","components","parsedType","file","json","object","types","bodyMap","computed","txt","methods","fileInput","document","getElementById","dispatchEvent","MouseEvent","e","target","files","parseData","vm","fr","FileReader","onload","result","$notify","error","title","message","startsWith","_vm$types$vm$object$n","concat","nRoleType","toString","label","$emit","onerror","readAsArrayBuffer","filters","created","mounted","window","component","isNull","isBoolean","isNumber","isString","isObject","isEmpty","fromPairs","repeat","parseLua","formatLuaString","string","singleQuote","valueKeys","false","true","null","formatLuaKey","format","options","spaces","rec","spacesEnd","Error","luaAstToJson","ast","includes","operator","argument","__internal_table_key","fields","field","values","init","arguments","body","comments","root","factory","objectTypes","freeExports","nodeType","freeModule","freeGlobal","global","moduleExports","self","input","version","defaultOptions","wait","scope","locations","ranges","onCreateNode","onCreateScope","onDestroyScope","EOF","StringLiteral","Keyword","Identifier","NumericLiteral","Punctuator","BooleanLiteral","NilLiteral","VarargLiteral","tokenTypes","errors","unexpected","expected","expectedToken","unfinishedString","malformedNumber","invalidVar","labelStatement","breakStatement","gotoStatement","returnStatement","args","ifStatement","clauses","ifClause","condition","elseifClause","elseClause","whileStatement","doStatement","repeatStatement","localStatement","variables","assignmentStatement","callStatement","expression","functionStatement","identifier","parameters","isLocal","forNumericStatement","variable","start","end","step","forGenericStatement","iterators","chunk","literal","raw","tableKey","tableKeyString","tableValue","tableConstructorExpression","binaryExpression","left","right","unaryExpression","memberExpression","base","indexer","indexExpression","index","callExpression","tableCallExpression","stringCallExpression","comment","finishNode","node","trackLocations","location","complete","loc","range","token","previousToken","lookahead","tokenStart","lineStart","scopes","scopeDepth","globals","array","element","indexOfObject","property","sprintf","extend","src","prop","dest","raise","col","apply","SyntaxError","column","raiseUnexpectedToken","found","near","lex","skipWhiteSpace","charCodeAt","scanComment","charCode","next","isIdentifierStart","scanIdentifierOrKeyword","scanStringLiteral","scanNumericLiteral","isDecDigit","scanVarargLiteral","scanPunctuator","scanLongStringLiteral","consumeEOL","peekCharCode","isLineTerminator","isWhiteSpace","isIdentifierPart","isKeyword","delimiter","stringStart","readEscapeSequence","fromCharCode","readLongString","character","readHexLiteral","readDecLiteral","digit","fractionStart","exponentStart","digitStart","fraction","binaryExponent","binarySign","isHexDigit","Math","pow","sequenceStart","isLong","commentStart","lineStartComment","lineComment","level","terminator","consume","expect","id","isUnary","isCallExpression","isBlockFollow","createScope","destroyScope","scopeIdentifierName","scopeIdentifier","attachScope","scopeHasName","createLocationMarker","Marker","markLocation","pushLocation","marker","parseChunk","parseBlock","statement","block","parseStatement","parseLocalStatement","parseIfStatement","parseReturnStatement","parseFunctionName","parseFunctionDeclaration","parseWhileStatement","parseForStatement","parseRepeatStatement","parseBreakStatement","parseDoStatement","parseGotoStatement","parseLabelStatement","parseAssignmentOrCallStatement","parseIdentifier","parseExpectedExpression","expressions","parseExpression","validateVar","inParens","previous","parsePrefixExpression","exp","parameter","parsePrimaryExpression","parseTableConstructor","parseSubExpression","binaryPrecedence","minPrecedence","precedence","parseCallExpression","table","literals","_input","_options","write"],"mappings":"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","file":"js/chunk-d271c59a.eefecd9d.js","sourcesContent":["export * from \"-!../../../mini-css-extract-plugin/dist/loader.js??ref--11-oneOf-1-0!../../../css-loader/dist/cjs.js??ref--11-oneOf-1-1!../../../vue-loader/lib/loaders/stylePostLoader.js!../../../postcss-loader/src/index.js??ref--11-oneOf-1-2!../../../less-loader/dist/cjs.js??ref--11-oneOf-1-3!../../../style-resources-loader/lib/index.js??ref--11-oneOf-1-4!../../../cache-loader/dist/cjs.js??ref--1-0!../../../vue-loader/lib/index.js??vue-loader-options!../../../vue-svg-inline-loader/dist/index.min.js!./Upload.vue?vue&type=style&index=0&id=0e8d012a&prod&lang=less&\"","const { hasOwnProperty } = Object.prototype\n\nconst eol = typeof process !== 'undefined' &&\n  process.platform === 'win32' ? '\\r\\n' : '\\n'\n\nconst encode = (obj, opt) => {\n  const children = []\n  let out = ''\n\n  if (typeof opt === 'string') {\n    opt = {\n      section: opt,\n      whitespace: false,\n    }\n  } else {\n    opt = opt || Object.create(null)\n    opt.whitespace = opt.whitespace === true\n  }\n\n  const separator = opt.whitespace ? ' = ' : '='\n\n  for (const k of Object.keys(obj)) {\n    const val = obj[k]\n    if (val && Array.isArray(val)) {\n      for (const item of val)\n        out += safe(k + '[]') + separator + safe(item) + '\\n'\n    } else if (val && typeof val === 'object')\n      children.push(k)\n    else\n      out += safe(k) + separator + safe(val) + eol\n  }\n\n  if (opt.section && out.length)\n    out = '[' + safe(opt.section) + ']' + eol + out\n\n  for (const k of children) {\n    const nk = dotSplit(k).join('\\\\.')\n    const section = (opt.section ? opt.section + '.' : '') + nk\n    const { whitespace } = opt\n    const child = encode(obj[k], {\n      section,\n      whitespace,\n    })\n    if (out.length && child.length)\n      out += eol\n\n    out += child\n  }\n\n  return out\n}\n\nconst dotSplit = str =>\n  str.replace(/\\1/g, '\\u0002LITERAL\\\\1LITERAL\\u0002')\n    .replace(/\\\\\\./g, '\\u0001')\n    .split(/\\./)\n    .map(part =>\n      part.replace(/\\1/g, '\\\\.')\n        .replace(/\\2LITERAL\\\\1LITERAL\\2/g, '\\u0001'))\n\nconst decode = str => {\n  const out = Object.create(null)\n  let p = out\n  let section = null\n  //          section     |key      = value\n  const re = /^\\[([^\\]]*)\\]$|^([^=]+)(=(.*))?$/i\n  const lines = str.split(/[\\r\\n]+/g)\n\n  for (const line of lines) {\n    if (!line || line.match(/^\\s*[;#]/))\n      continue\n    const match = line.match(re)\n    if (!match)\n      continue\n    if (match[1] !== undefined) {\n      section = unsafe(match[1])\n      if (section === '__proto__') {\n        // not allowed\n        // keep parsing the section, but don't attach it.\n        p = Object.create(null)\n        continue\n      }\n      p = out[section] = out[section] || Object.create(null)\n      continue\n    }\n    const keyRaw = unsafe(match[2])\n    const isArray = keyRaw.length > 2 && keyRaw.slice(-2) === '[]'\n    const key = isArray ? keyRaw.slice(0, -2) : keyRaw\n    if (key === '__proto__')\n      continue\n    const valueRaw = match[3] ? unsafe(match[4]) : true\n    const value = valueRaw === 'true' ||\n      valueRaw === 'false' ||\n      valueRaw === 'null' ? JSON.parse(valueRaw)\n      : valueRaw\n\n    // Convert keys with '[]' suffix to an array\n    if (isArray) {\n      if (!hasOwnProperty.call(p, key))\n        p[key] = []\n      else if (!Array.isArray(p[key]))\n        p[key] = [p[key]]\n    }\n\n    // safeguard against resetting a previously defined\n    // array by accidentally forgetting the brackets\n    if (Array.isArray(p[key]))\n      p[key].push(value)\n    else\n      p[key] = value\n  }\n\n  // {a:{y:1},\"a.b\":{x:2}} --> {a:{y:1,b:{x:2}}}\n  // use a filter to return the keys that have to be deleted.\n  const remove = []\n  for (const k of Object.keys(out)) {\n    if (!hasOwnProperty.call(out, k) ||\n        typeof out[k] !== 'object' ||\n        Array.isArray(out[k]))\n      continue\n\n    // see if the parent section is also an object.\n    // if so, add it to that, and mark this one for deletion\n    const parts = dotSplit(k)\n    let p = out\n    const l = parts.pop()\n    const nl = l.replace(/\\\\\\./g, '.')\n    for (const part of parts) {\n      if (part === '__proto__')\n        continue\n      if (!hasOwnProperty.call(p, part) || typeof p[part] !== 'object')\n        p[part] = Object.create(null)\n      p = p[part]\n    }\n    if (p === out && nl === l)\n      continue\n\n    p[nl] = out[k]\n    remove.push(k)\n  }\n  for (const del of remove)\n    delete out[del]\n\n  return out\n}\n\nconst isQuoted = val =>\n  (val.charAt(0) === '\"' && val.slice(-1) === '\"') ||\n    (val.charAt(0) === \"'\" && val.slice(-1) === \"'\")\n\nconst safe = val =>\n  (typeof val !== 'string' ||\n    val.match(/[=\\r\\n]/) ||\n    val.match(/^\\[/) ||\n    (val.length > 1 &&\n     isQuoted(val)) ||\n    val !== val.trim())\n    ? JSON.stringify(val)\n    : val.replace(/;/g, '\\\\;').replace(/#/g, '\\\\#')\n\nconst unsafe = (val, doUnesc) => {\n  val = (val || '').trim()\n  if (isQuoted(val)) {\n    // remove the single quotes before calling JSON.parse\n    if (val.charAt(0) === \"'\")\n      val = val.substr(1, val.length - 2)\n\n    try {\n      val = JSON.parse(val)\n    } catch (_) {}\n  } else {\n    // walk the val to find the first not-escaped ; character\n    let esc = false\n    let unesc = ''\n    for (let i = 0, l = val.length; i < l; i++) {\n      const c = val.charAt(i)\n      if (esc) {\n        if ('\\\\;#'.indexOf(c) !== -1)\n          unesc += c\n        else\n          unesc += '\\\\' + c\n\n        esc = false\n      } else if (';#'.indexOf(c) !== -1)\n        break\n      else if (c === '\\\\')\n        esc = true\n      else\n        unesc += c\n    }\n    if (esc)\n      unesc += '\\\\'\n\n    return unesc.trim()\n  }\n  return val\n}\n\nmodule.exports = {\n  parse: decode,\n  decode,\n  stringify: encode,\n  encode,\n  safe,\n  unsafe,\n}\n","var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',{staticClass:\"c-facedat-upload\"},[(_vm.support)?_c('div',{staticClass:\"u-upload\"},[(!_vm.done)?[_c('input',{staticClass:\"u-input\",attrs:{\"type\":\"file\",\"id\":\"face_file\",\"accept\":\".dat,.jx3dat,.ini\"},on:{\"change\":_vm.uploadData}}),_c('el-button',{staticClass:\"u-btn\",attrs:{\"type\":\"primary\",\"icon\":\"el-icon-upload2\"},on:{\"click\":_vm.selectData}},[_vm._v(_vm._s(_vm.btnText))]),(_vm.type === 'face')?_c('a',{staticClass:\"u-help\",attrs:{\"href\":\"/tool/746\",\"target\":\"_blank\"}},[_c('i',{staticClass:\"el-icon-collection\"}),_vm._v(\" 游戏脸型导入导出指南 \")]):_vm._e()]:[_c('div',{staticClass:\"u-result\"},[_c('el-button',{staticClass:\"u-reset\",attrs:{\"icon\":\"el-icon-refresh-left\"},on:{\"click\":_vm.resetData}},[_vm._v(\"清空重置\")]),_c('el-alert',{attrs:{\"title\":'当前文件为：' + _vm.filename,\"type\":\"success\",\"show-icon\":\"\"}})],1)]],2):_c('el-alert',{staticClass:\"u-notsupport\",attrs:{\"title\":\"浏览器不支持\",\"type\":\"warning\",\"description\":\"你的浏览器太老旧不支持本地读取,请更换chrome或其它现代浏览器\",\"show-icon\":\"\"}})],1)\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","/* INI 格式捏脸转 LuaTable 格式 */\r\n\r\n// 读 Face 节下指定键的数值\r\nfunction getFaceProperty(ini, key, defaultValue=0) {\r\n    return parseInt(ini[\"Face\"][key]) || defaultValue;\r\n}\r\n\r\n// 读指定键的 Decal 数值组\r\nfunction getDecalSection(ini, sectionName) {\r\n    let content = {\r\n        \"bUse\": !!parseInt(ini[\"CustomDetail\"][sectionName + \"_valueEnable\"]),\r\n        \"nShowID\": parseInt(ini[\"Decal\"][sectionName]) || 0,\r\n        \"nColorID\": parseInt(ini[\"Decal\"][sectionName + \"_color\"]) || 0,\r\n        \"fValue1\": -1,\r\n        \"fValue2\": -1,\r\n        \"fValue3\": -1\r\n    };\r\n    if(content[\"bUse\"]) {\r\n        content[\"fValue1\"] = parseFloat(ini[\"CustomDetail\"][sectionName + \"_value1\"]) || 0;\r\n        content[\"fValue2\"] = parseFloat(ini[\"CustomDetail\"][sectionName + \"_value2\"]) || 0;\r\n        content[\"fValue3\"] = parseFloat(ini[\"CustomDetail\"][sectionName + \"_value3\"]) || 0;\r\n    }\r\n    return content;\r\n}\r\n\r\n// INI 格式转 LuaTable 格式\r\nexport function convertFaceIni(ini) {\r\n    return {\r\n        \"nRoleType\": parseInt(ini[\"Base\"][\"RoleType\"]),\r\n        \"nDecorationID\": parseInt(ini[\"Base\"][\"DecorationID\"]),\r\n        \"tDecal\": {\r\n            \"BASE\": getDecalSection(ini, \"FaceBaseTexture\"),\r\n            \"BROW\": getDecalSection(ini, \"Brow\"),\r\n            \"EYE_LIGHT\": getDecalSection(ini, \"EyeLight\"),\r\n            \"EYE_LINE\": getDecalSection(ini, \"EyeLine\"),\r\n            \"EYE_SHADOW\": getDecalSection(ini, \"EyeShadow\"),\r\n            \"EYE_SHADOW1\": getDecalSection(ini, \"EyeShadow1\"),\r\n            \"EYE_SHADOW2\": getDecalSection(ini, \"EyeShadow2\"),\r\n            \"EYE_SHADOW3\": getDecalSection(ini, \"EyeShadow3\"),\r\n            \"EYE_SHADOW4\": getDecalSection(ini, \"EyeShadow4\"),\r\n            \"EYE_SHADOW_FLASH1\": getDecalSection(ini, \"EyeShadowFlash1\"),\r\n            \"EYE_SHADOW_FLASH2\": getDecalSection(ini, \"EyeShadowFlash2\"),\r\n            \"EYE_SHADOW_FLASH3\": getDecalSection(ini, \"EyeShadowFlash3\"),\r\n            \"EYE_SHADOW_FLASH4\": getDecalSection(ini, \"EyeShadowFlash4\"),\r\n            \"LIP_LIGHT\": getDecalSection(ini, \"LipLight\"),\r\n            \"LIP_FLASH\": getDecalSection(ini, \"LipFlash\"),\r\n            \"LIP_GLOSS\": getDecalSection(ini, \"LipGloss\"),\r\n            \"LIP_OVERLAP\":getDecalSection(ini, \"LipOverlap\"),\r\n            \"IRIS_LEFT\": getDecalSection(ini, \"IrisLeft\"),\r\n            \"IRIS_RIGHT\": getDecalSection(ini, \"IrisRight\"),\r\n            \"BLUSHER_MOUSTACHE\": getDecalSection(ini, \"BlusherMoustache\"),\r\n            \"DECAL\": getDecalSection(ini, \"Decal\")\r\n        },\r\n        \"tBone\": {\r\n            \"NOSE_SIZE\": getFaceProperty(ini, \"noseSize\"),\r\n            \"UP_LIP_OUT\": getFaceProperty(ini, \"upLipOut\"),\r\n            \"NOSEBOW_WIDTH\": getFaceProperty(ini, \"nosebowWidth\"),\r\n            \"MOUTH_OPEN\": getFaceProperty(ini, \"mouthOpen\"),\r\n            \"CHEEK_Y\": getFaceProperty(ini, \"cheekY\"),\r\n            \"EYE_OPEN\": getFaceProperty(ini, \"eyeOpen\"),\r\n            \"FACE_Y\": getFaceProperty(ini, \"faceY\"),\r\n            \"MOUTH_END_L\": getFaceProperty(ini, \"mouthEndL\"),\r\n            \"JAW_LENGTH\": getFaceProperty(ini, \"jawLength\"),\r\n            \"UP_LIP\": getFaceProperty(ini, \"upLip\"),\r\n            \"EYE_DIST\": getFaceProperty(ini, \"eyeDist\"),\r\n            \"NOSETOP_POS_Y\": getFaceProperty(ini, \"nosetopPosY\"),\r\n            \"EYE_DIRC\": getFaceProperty(ini, \"eyeDirc\"),\r\n            \"EYEBOW_OUT\": getFaceProperty(ini, \"eyebowOut\"),\r\n            \"MOUTH_OUT\": getFaceProperty(ini, \"mouthOut\"),\r\n            \"RIDGE_Y\": getFaceProperty(ini, \"ridgeY\"),\r\n            \"MOUTH_END\": getFaceProperty(ini, \"mouthEnd\"),\r\n            \"NOSEBOW_BEND\": getFaceProperty(ini, \"nosebowBend\"),\r\n            \"JAW_WIDTH\": getFaceProperty(ini, \"jawWidth\"),\r\n            \"LOW_LIP_POS\": getFaceProperty(ini, \"lowLipPos\"),\r\n            \"PUPIL_DIRC\": getFaceProperty(ini, \"pupilDirc\"),\r\n            \"NOSETOP_POS_Z\": getFaceProperty(ini, \"nosetopPosZ\"),\r\n            \"MOUTH_POS\": getFaceProperty(ini, \"mouthPos\"),\r\n            \"MOUTH_SIZE\": getFaceProperty(ini, \"mouthSize\"),\r\n            \"LOW_LIP\": getFaceProperty(ini, \"lowLip\"),\r\n            \"FACE_Z\": getFaceProperty(ini, \"faceZ\"),\r\n            \"NOSETOP_WIDTH\": getFaceProperty(ini, \"nosetopWidth\"),\r\n            \"UP_FACE\": getFaceProperty(ini, \"upFace\"),\r\n            \"UP_LID_POS\": getFaceProperty(ini, \"upLidPos\"),\r\n            \"EYEBOW_POS\": getFaceProperty(ini, \"eyebowPos\"),\r\n            \"EYEBOW_DIRC\": getFaceProperty(ini, \"eyebowDirc\"),\r\n            \"UP_LIP_POS\": getFaceProperty(ini, \"upLipPos\"),\r\n            \"LOW_LIP_OUT\": getFaceProperty(ini, \"lowLipOut\"),\r\n            \"MOUTH_ROT\": getFaceProperty(ini, \"mouthRot\"),\r\n            \"EYE_SIZE\": getFaceProperty(ini, \"eyeSize\"),\r\n            \"EYE_POS\": getFaceProperty(ini, \"eyePos\"),\r\n            \"JAW_ROT\": getFaceProperty(ini, \"jawRot\"),\r\n            \"JAW_END\": getFaceProperty(ini, \"jawEnd\"),\r\n            \"EYECROW_Y\": getFaceProperty(ini, \"eyecrowY\"),\r\n            \"NOSETOP_UP\": getFaceProperty(ini, \"nosetopUp\"),\r\n            \"MOUTH_END_R\": getFaceProperty(ini, \"mouthEndR\"),\r\n            \"OUT\": getFaceProperty(ini, \"out\"),\r\n            \"JAW_POS\": getFaceProperty(ini, \"jawPos\"),\r\n            \"LOW_FACE\": getFaceProperty(ini, \"lowFace\"),\r\n            \"CHEEK_Z\": getFaceProperty(ini, \"cheekZ\"),\r\n            \"PUPIL_SIZE\": getFaceProperty(ini, \"pupilSize\"),\r\n            \"FACE_SCALE\": getFaceProperty(ini, \"faceScale\"),\r\n            \"NOSE_HEIGHT\": getFaceProperty(ini, \"noseHeight\"),\r\n            \"LOW_LID_POS\": getFaceProperty(ini, \"lowLidPos\")\r\n        }\r\n    };\r\n}\r\n","import * as KData from \"./KData\";\r\nimport { parse as luaJsonParse } from \"lua-json\";\r\nimport { serializer as luadata } from \"luadata\";\r\nimport { parse as iniParse } from \"ini\";\r\nimport { convertFaceIni } from \"./FaceINIConverter\";\r\nimport { load as convertBody } from \"./BodyConverter\";\r\n\r\n/**\r\n * 加载数据，若解析成功返回数据类型和数据，否则返回 null\r\n * @param {Uint8Array} buf \r\n * @return {object} {type: \"face\" | \"face_ini\" | \"body\", data: object} | null\r\n */\r\nexport function load(buf) {\r\n    const payload = KData.load(buf);\r\n\r\n    // 先尝试作为 LuaTable 解析\r\n    let lua;\r\n    try {\r\n        lua = luadata.unserialize(payload);\r\n        console.log(\"数据作为 LuaTable 解析成功\");\r\n        if (lua.get(\"tBone\")) {\r\n            console.log(\"数据为脸型数据\");\r\n            return {\r\n                type: \"face\",\r\n                data: luaJsonParse(\"return \" + payload),    // 为了和之前的代码保持兼容，暂时不更换 lua-json，要手动加回去 return\r\n            }\r\n        }\r\n        else if (lua.get(\"tBody\")) {\r\n            console.log(\"数据为体型数据\");\r\n            return {\r\n                type: \"body\",\r\n                data: convertBody(lua),\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        // 作为 LuaTable 解析失败再尝试作为 INI 解析\r\n        try {\r\n            const ini = iniParse(payload);\r\n            const face = convertFaceIni(ini);\r\n            console.log(\"数据作为 INI 解析成功\");\r\n            return {\r\n                type: \"face_ini\",\r\n                data: face,\r\n            }\r\n        }\r\n        catch {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n","<template>\n  <div class=\"c-facedat-upload\">\n    <div class=\"u-upload\" v-if=\"support\">\n      <template v-if=\"!done\">\n        <input\n          class=\"u-input\"\n          type=\"file\"\n          id=\"face_file\"\n          accept=\".dat,.jx3dat,.ini\"\n          @change=\"uploadData\"\n        />\n        <el-button\n          class=\"u-btn\"\n          type=\"primary\"\n          @click=\"selectData\"\n          icon=\"el-icon-upload2\"\n          >{{ btnText }}</el-button\n        >\n        <a\n          v-if=\"type === 'face'\"\n          class=\"u-help\"\n          href=\"/tool/746\"\n          target=\"_blank\"\n        >\n          <i class=\"el-icon-collection\"></i> 游戏脸型导入导出指南\n        </a>\n      </template>\n      <template v-else>\n        <div class=\"u-result\">\n          <el-button\n            class=\"u-reset\"\n            @click=\"resetData\"\n            icon=\"el-icon-refresh-left\"\n            >清空重置</el-button\n          >\n          <el-alert\n            :title=\"'当前文件为：' + filename\"\n            type=\"success\"\n            show-icon\n          ></el-alert>\n        </div>\n      </template>\n    </div>\n    <el-alert\n      v-else\n      class=\"u-notsupport\"\n      title=\"浏览器不支持\"\n      type=\"warning\"\n      description=\"你的浏览器太老旧不支持本地读取,请更换chrome或其它现代浏览器\"\n      show-icon\n    ></el-alert>\n  </div>\n</template>\n\n<script>\nimport types from \"../assets/data/index.json\";\nimport { load } from \"./DataRouter\";\n\nexport default {\n  name: \"Upload\",\n  props: {\n    type: {\n      type: String,\n      default: \"\",\n    },\n  },\n  components: {},\n  data: function () {\n    return {\n      support: true,\n\n      parsedType: \"\", //解析出的类型\n      file: \"\", //文件对象\n      json: \"\", //json data\n      object: \"\", //js object\n\n      done: false,\n      types: types.bodyMap,\n    };\n  },\n  computed: {\n    btnText() {\n      let txt = \"上传脸型/体型数据\";\n      if (this.type === \"face\") {\n        txt = \"上传脸型数据\";\n      }\n      if (this.type === \"body\") {\n        txt = \"上传体型数据\";\n      }\n      return txt;\n    },\n    filename: function () {\n      return this.file && this.file.name;\n    },\n  },\n  methods: {\n    // 上传数据\n    selectData: function (i) {\n      let fileInput = document.getElementById(\"face_file\");\n      fileInput.dispatchEvent(new MouseEvent(\"click\"));\n    },\n    uploadData: function (e) {\n      let file = e.target.files[0];\n      this.file = file;\n      this.parseData(file);\n    },\n    // 读取与读取数据\n    parseData: function (file) {\n      if (!file) return; //空数据不读取\n      const vm = this;\n\n      // 读入 File 转 ArrayBuffer 进行读取\n      let fr = new FileReader();\n      fr.onload = function (e) {\n        console.log(\"文件读取成功...开始执行分析...\");\n        const result = load(e.target.result);\n        if (!result)\n          return vm.$notify.error({\n            title: \"错误\",\n            message: \"数据类型解析失败\",\n          });\n        if (result.type.startsWith(\"face\")) {\n          if (vm.type && vm.type !== \"face\") {\n            return vm.$notify.error({\n              title: \"错误\",\n              message: \"请导入脸型数据\",\n            });\n          } else {\n            vm.parsedType = \"face\";\n            vm.object = result.data;\n          }\n        } else if (result.type === \"body\") {\n          if (vm.type && vm.type !== \"body\") {\n            return vm.$notify.error({\n              title: \"错误\",\n              message: \"请导入体型数据\",\n            });\n          } else {\n            vm.parsedType = \"body\";\n            vm.object = result.data;\n          }\n        }\n\n        // 读取成功才分析\n        if (vm.object) {\n          try {\n            vm.json = JSON.stringify(vm.object);\n            vm.$notify({\n              title: \"成功\",\n              message: `${\n                vm.types[vm.object.nRoleType.toString()]?.label || \"\"\n              }${\n                vm.parsedType === \"face\"\n                  ? \"脸型\"\n                  : vm.parsedType === \"body\"\n                  ? \"体型\"\n                  : \"\"\n              }数据读取成功`,\n              type: \"success\",\n            });\n            vm.done = true;\n            vm.$emit(\"success\", {\n              type: vm.parsedType,\n              file: vm.file,\n              json: vm.json,\n              object: vm.object,\n            });\n          } catch (e) {\n            vm.$notify.error({\n              title: \"错误\",\n              message: \"无法读取数据\",\n            });\n            vm.$emit(\"fail\", {\n              file: vm.file,\n            });\n          }\n        }\n      };\n      fr.onerror = function (e) {\n        vm.$notify.error({\n          title: \"错误\",\n          message: \"文件读取异常\",\n        });\n      };\n      fr.readAsArrayBuffer(file);\n    },\n    // 重置上传\n    resetData: function () {\n      this.done = false;\n\n      this.file = \"\";\n      this.json = \"\";\n      this.object = \"\";\n      this.$emit(\"success\", {\n        file: \"\",\n        json: \"\",\n        object: \"\",\n      });\n    },\n  },\n  filters: {},\n  created: function () {},\n  mounted: function () {\n    this.support = !!window.FileReader;\n  },\n};\n</script>\n\n<style lang=\"less\">\n.c-facedat-upload {\n  .u-tip {\n    .fz(12px);\n    color: #999;\n  }\n  .mt(20px);\n  .u-input {\n    .none;\n  }\n  .u-upload {\n    .x;\n  }\n  .u-help {\n    .fz(12px,3);\n    color: @color-link;\n    .underline(@color-link);\n    i {\n      .fz(14px);\n      .y(-1px);\n    }\n  }\n  .u-btn {\n    .db;\n    margin: 0 auto;\n    .size(200px,50px);\n  }\n  .u-file {\n    .fz(14px,2);\n    color: #49c10f;\n    .bold;\n  }\n  .u-reset {\n    .mb(10px);\n  }\n}\n</style>\n","import mod from \"-!../../../cache-loader/dist/cjs.js??ref--13-0!../../../thread-loader/dist/cjs.js!../../../babel-loader/lib/index.js!../../../cache-loader/dist/cjs.js??ref--1-0!../../../vue-loader/lib/index.js??vue-loader-options!../../../vue-svg-inline-loader/dist/index.min.js!./Upload.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../cache-loader/dist/cjs.js??ref--13-0!../../../thread-loader/dist/cjs.js!../../../babel-loader/lib/index.js!../../../cache-loader/dist/cjs.js??ref--1-0!../../../vue-loader/lib/index.js??vue-loader-options!../../../vue-svg-inline-loader/dist/index.min.js!./Upload.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./Upload.vue?vue&type=template&id=0e8d012a&\"\nimport script from \"./Upload.vue?vue&type=script&lang=js&\"\nexport * from \"./Upload.vue?vue&type=script&lang=js&\"\nimport style0 from \"./Upload.vue?vue&type=style&index=0&id=0e8d012a&prod&lang=less&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","const { isNull, isBoolean, isNumber, isString, isArray, isObject, isEmpty, fromPairs, keys, map, repeat } = require('lodash')\nconst { parse: parseLua } = require('luaparse')\n\nconst formatLuaString = (string, singleQuote) => (singleQuote ? `'${string.replace(/'/g, \"\\\\'\")}'` : `\"${string.replace(/\"/g, '\\\\\"')}\"`)\n\nconst valueKeys = { false: 'false', true: 'true', null: 'nil' }\n\nconst formatLuaKey = (string, singleQuote) =>\n  valueKeys[string] ? `[${valueKeys[string]}]` : string.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? string : `[${formatLuaString(string, singleQuote)}]`\n\nconst format = (value, options = { eol: '\\n', singleQuote: true, spaces: 2 }) => {\n  options = options || {}\n  const eol = (options.eol = isString(options.eol) ? options.eol : '\\n')\n  options.singleQuote = isBoolean(options.singleQuote) ? options.singleQuote : true\n  options.spaces = isNull(options.spaces) || isNumber(options.spaces) || isString(options.spaces) ? options.spaces : 2\n\n  const rec = (value, i = 0) => {\n    if (isNull(value)) {\n      return 'nil'\n    }\n    if (isBoolean(value) || isNumber(value)) {\n      return value.toString()\n    }\n    if (isString(value)) {\n      return formatLuaString(value, options.singleQuote)\n    }\n    if (isArray(value)) {\n      if (isEmpty(value)) {\n        return '{}'\n      }\n      if (options.spaces) {\n        const spaces = isNumber(options.spaces) ? repeat(' ', options.spaces * (i + 1)) : repeat(options.spaces, i + 1)\n        const spacesEnd = isNumber(options.spaces) ? repeat(' ', options.spaces * i) : repeat(options.spaces, i)\n        return `{${eol}${value.map(e => `${spaces}${rec(e, i + 1)},`).join(eol)}${eol}${spacesEnd}}`\n      }\n      return `{${value.map(e => `${rec(e, i + 1)},`).join('')}}`\n    }\n    if (isObject(value)) {\n      if (isEmpty(value)) {\n        return '{}'\n      }\n      if (options.spaces) {\n        const spaces = isNumber(options.spaces) ? repeat(' ', options.spaces * (i + 1)) : repeat(options.spaces, i + 1)\n        const spacesEnd = isNumber(options.spaces) ? repeat(' ', options.spaces * i) : repeat(options.spaces, i)\n        return `{${eol}${keys(value)\n          .map(key => `${spaces}${formatLuaKey(key, options.singleQuote)} = ${rec(value[key], i + 1)},`)\n          .join(eol)}${eol}${spacesEnd}}`\n      }\n      return `{${keys(value)\n        .map(key => `${formatLuaKey(key, options.singleQuote)}=${rec(value[key], i + 1)},`)\n        .join('')}}`\n    }\n    throw new Error(`can't format ${typeof value}`)\n  }\n\n  return `return${options.spaces ? ' ' : ''}${rec(value)}`\n}\n\nconst luaAstToJson = ast => {\n  // literals\n  if (['NilLiteral', 'BooleanLiteral', 'NumericLiteral', 'StringLiteral'].includes(ast.type)) {\n    return ast.value\n  }\n  // basic expressions\n  if (ast.type === 'UnaryExpression' && ast.operator === '-') {\n    return -luaAstToJson(ast.argument)\n  }\n  if (ast.type === 'Identifier') {\n    return ast.name\n  }\n  // tables\n  if (['TableKey', 'TableKeyString'].includes(ast.type)) {\n    return { __internal_table_key: true, key: luaAstToJson(ast.key), value: luaAstToJson(ast.value) }\n  }\n  if (ast.type === 'TableValue') {\n    return luaAstToJson(ast.value)\n  }\n  if (ast.type === 'TableConstructorExpression') {\n    if (ast.fields[0] && ast.fields[0].key) {\n      const object = fromPairs(\n        map(ast.fields, field => {\n          const { key, value } = luaAstToJson(field)\n          return [key, value]\n        }),\n      )\n      return isEmpty(object) ? [] : object\n    }\n    return map(ast.fields, field => {\n      const value = luaAstToJson(field)\n      return value.__internal_table_key ? [value.key, value.value] : value\n    })\n  }\n  // top-level statements, only looking at the first statement, either return or local\n  // todo: filter until return or local?\n  if (ast.type === 'LocalStatement') {\n    const values = ast.init.map(luaAstToJson)\n    return values.length === 1 ? values[0] : values\n  }\n  if (ast.type === 'ReturnStatement') {\n    const values = ast.arguments.map(luaAstToJson)\n    return values.length === 1 ? values[0] : values\n  }\n  if (ast.type === 'Chunk') {\n    return luaAstToJson(ast.body[0])\n  }\n  throw new Error(`can't parse ${ast.type}`)\n}\n\nconst parse = value => luaAstToJson(parseLua(value, { comments: false }))\n\nmodule.exports = {\n  format,\n  parse,\n}\n","/* global exports:true, module:true, require:true, define:true, global:true */\n\n(function (root, name, factory) {\n  /* jshint eqeqeq:false */\n  'use strict';\n\n  // Used to determine if values are of the language type `Object`\n  var objectTypes = {\n        'function': true\n      , 'object': true\n    }\n    // Detect free variable `exports`\n    , freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports\n    // Detect free variable `module`\n    , freeModule = objectTypes[typeof module] && module && !module.nodeType && module\n    // Detect free variable `global`, from Node.js or Browserified code, and\n    // use it as `window`\n    , freeGlobal = freeExports && freeModule && typeof global == 'object' && global\n    // Detect the popular CommonJS extension `module.exports`\n    , moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  // Some AMD build optimizers, like r.js, check for specific condition\n  // patterns like the following:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // defined as an anonymous module.\n    define(['exports'], factory);\n    // In case the source has been processed and wrapped in a define module use\n    // the supplied `exports` object.\n    if (freeExports && moduleExports) factory(freeModule.exports);\n  }\n  // check for `exports` after `define` in case a build optimizer adds an\n  // `exports` object\n  else if (freeExports && freeModule) {\n    // in Node.js or RingoJS v0.8.0+\n    if (moduleExports) factory(freeModule.exports);\n    // in Narwhal or RingoJS v0.7.0-\n    else factory(freeExports);\n  }\n  // in a browser or Rhino\n  else {\n    factory((root[name] = {}));\n  }\n}(this, 'luaparse', function (exports) {\n  'use strict';\n\n  exports.version = '0.2.1';\n\n  var input, options, length;\n\n  // Options can be set either globally on the parser object through\n  // defaultOptions, or during the parse call.\n  var defaultOptions = exports.defaultOptions = {\n    // Explicitly tell the parser when the input ends.\n      wait: false\n    // Store comments as an array in the chunk object.\n    , comments: true\n    // Track identifier scopes by adding an isLocal attribute to each\n    // identifier-node.\n    , scope: false\n    // Store location information on each syntax node as\n    // `loc: { start: { line, column }, end: { line, column } }`.\n    , locations: false\n    // Store the start and end character locations on each syntax node as\n    // `range: [start, end]`.\n    , ranges: false\n    // A callback which will be invoked when a syntax node has been completed.\n    // The node which has been created will be passed as the only parameter.\n    , onCreateNode: null\n    // A callback which will be invoked when a new scope is created.\n    , onCreateScope: null\n    // A callback which will be invoked when the current scope is destroyed.\n    , onDestroyScope: null\n  };\n\n  // The available tokens expressed as enum flags so they can be checked with\n  // bitwise operations.\n\n  var EOF = 1, StringLiteral = 2, Keyword = 4, Identifier = 8\n    , NumericLiteral = 16, Punctuator = 32, BooleanLiteral = 64\n    , NilLiteral = 128, VarargLiteral = 256;\n\n  exports.tokenTypes = { EOF: EOF, StringLiteral: StringLiteral\n    , Keyword: Keyword, Identifier: Identifier, NumericLiteral: NumericLiteral\n    , Punctuator: Punctuator, BooleanLiteral: BooleanLiteral\n    , NilLiteral: NilLiteral, VarargLiteral: VarargLiteral\n  };\n\n  // As this parser is a bit different from luas own, the error messages\n  // will be different in some situations.\n\n  var errors = exports.errors = {\n      unexpected: 'unexpected %1 \\'%2\\' near \\'%3\\''\n    , expected: '\\'%1\\' expected near \\'%2\\''\n    , expectedToken: '%1 expected near \\'%2\\''\n    , unfinishedString: 'unfinished string near \\'%1\\''\n    , malformedNumber: 'malformed number near \\'%1\\''\n    , invalidVar: 'invalid left-hand side of assignment near \\'%1\\''\n  };\n\n  // ### Abstract Syntax Tree\n  //\n  // The default AST structure is inspired by the Mozilla Parser API but can\n  // easily be customized by overriding these functions.\n\n  var ast = exports.ast = {\n      labelStatement: function(label) {\n      return {\n          type: 'LabelStatement'\n        , label: label\n      };\n    }\n\n    , breakStatement: function() {\n      return {\n          type: 'BreakStatement'\n      };\n    }\n\n    , gotoStatement: function(label) {\n      return {\n          type: 'GotoStatement'\n        , label: label\n      };\n    }\n\n    , returnStatement: function(args) {\n      return {\n          type: 'ReturnStatement'\n        , 'arguments': args\n      };\n    }\n\n    , ifStatement: function(clauses) {\n      return {\n          type: 'IfStatement'\n        , clauses: clauses\n      };\n    }\n    , ifClause: function(condition, body) {\n      return {\n          type: 'IfClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseifClause: function(condition, body) {\n      return {\n          type: 'ElseifClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseClause: function(body) {\n      return {\n          type: 'ElseClause'\n        , body: body\n      };\n    }\n\n    , whileStatement: function(condition, body) {\n      return {\n          type: 'WhileStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , doStatement: function(body) {\n      return {\n          type: 'DoStatement'\n        , body: body\n      };\n    }\n\n    , repeatStatement: function(condition, body) {\n      return {\n          type: 'RepeatStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , localStatement: function(variables, init) {\n      return {\n          type: 'LocalStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , assignmentStatement: function(variables, init) {\n      return {\n          type: 'AssignmentStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , callStatement: function(expression) {\n      return {\n          type: 'CallStatement'\n        , expression: expression\n      };\n    }\n\n    , functionStatement: function(identifier, parameters, isLocal, body) {\n      return {\n          type: 'FunctionDeclaration'\n        , identifier: identifier\n        , isLocal: isLocal\n        , parameters: parameters\n        , body: body\n      };\n    }\n\n    , forNumericStatement: function(variable, start, end, step, body) {\n      return {\n          type: 'ForNumericStatement'\n        , variable: variable\n        , start: start\n        , end: end\n        , step: step\n        , body: body\n      };\n    }\n\n    , forGenericStatement: function(variables, iterators, body) {\n      return {\n          type: 'ForGenericStatement'\n        , variables: variables\n        , iterators: iterators\n        , body: body\n      };\n    }\n\n    , chunk: function(body) {\n      return {\n          type: 'Chunk'\n        , body: body\n      };\n    }\n\n    , identifier: function(name) {\n      return {\n          type: 'Identifier'\n        , name: name\n      };\n    }\n\n    , literal: function(type, value, raw) {\n      type = (type === StringLiteral) ? 'StringLiteral'\n        : (type === NumericLiteral) ? 'NumericLiteral'\n        : (type === BooleanLiteral) ? 'BooleanLiteral'\n        : (type === NilLiteral) ? 'NilLiteral'\n        : 'VarargLiteral';\n\n      return {\n          type: type\n        , value: value\n        , raw: raw\n      };\n    }\n\n    , tableKey: function(key, value) {\n      return {\n          type: 'TableKey'\n        , key: key\n        , value: value\n      };\n    }\n    , tableKeyString: function(key, value) {\n      return {\n          type: 'TableKeyString'\n        , key: key\n        , value: value\n      };\n    }\n    , tableValue: function(value) {\n      return {\n          type: 'TableValue'\n        , value: value\n      };\n    }\n\n\n    , tableConstructorExpression: function(fields) {\n      return {\n          type: 'TableConstructorExpression'\n        , fields: fields\n      };\n    }\n    , binaryExpression: function(operator, left, right) {\n      var type = ('and' === operator || 'or' === operator) ?\n        'LogicalExpression' :\n        'BinaryExpression';\n\n      return {\n          type: type\n        , operator: operator\n        , left: left\n        , right: right\n      };\n    }\n    , unaryExpression: function(operator, argument) {\n      return {\n          type: 'UnaryExpression'\n        , operator: operator\n        , argument: argument\n      };\n    }\n    , memberExpression: function(base, indexer, identifier) {\n      return {\n          type: 'MemberExpression'\n        , indexer: indexer\n        , identifier: identifier\n        , base: base\n      };\n    }\n\n    , indexExpression: function(base, index) {\n      return {\n          type: 'IndexExpression'\n        , base: base\n        , index: index\n      };\n    }\n\n    , callExpression: function(base, args) {\n      return {\n          type: 'CallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , tableCallExpression: function(base, args) {\n      return {\n          type: 'TableCallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , stringCallExpression: function(base, argument) {\n      return {\n          type: 'StringCallExpression'\n        , base: base\n        , argument: argument\n      };\n    }\n\n    , comment: function(value, raw) {\n      return {\n          type: 'Comment'\n        , value: value\n        , raw: raw\n      };\n    }\n  };\n\n  // Wrap up the node object.\n\n  function finishNode(node) {\n    // Pop a `Marker` off the location-array and attach its location data.\n    if (trackLocations) {\n      var location = locations.pop();\n      location.complete();\n      if (options.locations) node.loc = location.loc;\n      if (options.ranges) node.range = location.range;\n    }\n    if (options.onCreateNode) options.onCreateNode(node);\n    return node;\n  }\n\n\n  // Helpers\n  // -------\n\n  var slice = Array.prototype.slice\n    , toString = Object.prototype.toString\n    , indexOf = function indexOf(array, element) {\n      for (var i = 0, length = array.length; i < length; i++) {\n        if (array[i] === element) return i;\n      }\n      return -1;\n    };\n\n  // Iterate through an array of objects and return the index of an object\n  // with a matching property.\n\n  function indexOfObject(array, property, element) {\n    for (var i = 0, length = array.length; i < length; i++) {\n      if (array[i][property] === element) return i;\n    }\n    return -1;\n  }\n\n  // A sprintf implementation using %index (beginning at 1) to input\n  // arguments in the format string.\n  //\n  // Example:\n  //\n  //     // Unexpected function in token\n  //     sprintf('Unexpected %2 in %1.', 'token', 'function');\n\n  function sprintf(format) {\n    var args = slice.call(arguments, 1);\n    format = format.replace(/%(\\d)/g, function (match, index) {\n      return '' + args[index - 1] || '';\n    });\n    return format;\n  }\n\n  // Returns a new object with the properties from all objectes passed as\n  // arguments. Last argument takes precedence.\n  //\n  // Example:\n  //\n  //     this.options = extend(options, { output: false });\n\n  function extend() {\n    var args = slice.call(arguments)\n      , dest = {}\n      , src, prop;\n\n    for (var i = 0, length = args.length; i < length; i++) {\n      src = args[i];\n      for (prop in src) if (src.hasOwnProperty(prop)) {\n        dest[prop] = src[prop];\n      }\n    }\n    return dest;\n  }\n\n  // ### Error functions\n\n  // #### Raise an exception.\n  //\n  // Raise an exception by passing a token, a string format and its paramters.\n  //\n  // The passed tokens location will automatically be added to the error\n  // message if it exists, if not it will default to the lexers current\n  // position.\n  //\n  // Example:\n  //\n  //     // [1:0] expected [ near (\n  //     raise(token, \"expected %1 near %2\", '[', token.value);\n\n  function raise(token) {\n    var message = sprintf.apply(null, slice.call(arguments, 1))\n      , error, col;\n\n    if ('undefined' !== typeof token.line) {\n      col = token.range[0] - token.lineStart;\n      error = new SyntaxError(sprintf('[%1:%2] %3', token.line, col, message));\n      error.line = token.line;\n      error.index = token.range[0];\n      error.column = col;\n    } else {\n      col = index - lineStart + 1;\n      error = new SyntaxError(sprintf('[%1:%2] %3', line, col, message));\n      error.index = index;\n      error.line = line;\n      error.column = col;\n    }\n    throw error;\n  }\n\n  // #### Raise an unexpected token error.\n  //\n  // Example:\n  //\n  //     // expected <name> near '0'\n  //     raiseUnexpectedToken('<name>', token);\n\n  function raiseUnexpectedToken(type, token) {\n    raise(token, errors.expectedToken, type, token.value);\n  }\n\n  // #### Raise a general unexpected error\n  //\n  // Usage should pass either a token object or a symbol string which was\n  // expected. We can also specify a nearby token such as <eof>, this will\n  // default to the currently active token.\n  //\n  // Example:\n  //\n  //     // Unexpected symbol 'end' near '<eof>'\n  //     unexpected(token);\n  //\n  // If there's no token in the buffer it means we have reached <eof>.\n\n  function unexpected(found, near) {\n    if ('undefined' === typeof near) near = lookahead.value;\n    if ('undefined' !== typeof found.type) {\n      var type;\n      switch (found.type) {\n        case StringLiteral:   type = 'string';      break;\n        case Keyword:         type = 'keyword';     break;\n        case Identifier:      type = 'identifier';  break;\n        case NumericLiteral:  type = 'number';      break;\n        case Punctuator:      type = 'symbol';      break;\n        case BooleanLiteral:  type = 'boolean';     break;\n        case NilLiteral:\n          return raise(found, errors.unexpected, 'symbol', 'nil', near);\n      }\n      return raise(found, errors.unexpected, type, found.value, near);\n    }\n    return raise(found, errors.unexpected, 'symbol', found, near);\n  }\n\n  // Lexer\n  // -----\n  //\n  // The lexer, or the tokenizer reads the input string character by character\n  // and derives a token left-right. To be as efficient as possible the lexer\n  // prioritizes the common cases such as identifiers. It also works with\n  // character codes instead of characters as string comparisons was the\n  // biggest bottleneck of the parser.\n  //\n  // If `options.comments` is enabled, all comments encountered will be stored\n  // in an array which later will be appended to the chunk object. If disabled,\n  // they will simply be disregarded.\n  //\n  // When the lexer has derived a valid token, it will be returned as an object\n  // containing its value and as well as its position in the input string (this\n  // is always enabled to provide proper debug messages).\n  //\n  // `lex()` starts lexing and returns the following token in the stream.\n\n  var index\n    , token\n    , previousToken\n    , lookahead\n    , comments\n    , tokenStart\n    , line\n    , lineStart;\n\n  exports.lex = lex;\n\n  function lex() {\n    skipWhiteSpace();\n\n    // Skip comments beginning with --\n    while (45 === input.charCodeAt(index) &&\n           45 === input.charCodeAt(index + 1)) {\n      scanComment();\n      skipWhiteSpace();\n    }\n    if (index >= length) return {\n        type : EOF\n      , value: '<eof>'\n      , line: line\n      , lineStart: lineStart\n      , range: [index, index]\n    };\n\n    var charCode = input.charCodeAt(index)\n      , next = input.charCodeAt(index + 1);\n\n    // Memorize the range index where the token begins.\n    tokenStart = index;\n    if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();\n\n    switch (charCode) {\n      case 39: case 34: // '\"\n        return scanStringLiteral();\n\n      // 0-9\n      case 48: case 49: case 50: case 51: case 52: case 53:\n      case 54: case 55: case 56: case 57:\n        return scanNumericLiteral();\n\n      case 46: // .\n        // If the dot is followed by a digit it's a float.\n        if (isDecDigit(next)) return scanNumericLiteral();\n        if (46 === next) {\n          if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();\n          return scanPunctuator('..');\n        }\n        return scanPunctuator('.');\n\n      case 61: // =\n        if (61 === next) return scanPunctuator('==');\n        return scanPunctuator('=');\n\n      case 62: // >\n        if (61 === next) return scanPunctuator('>=');\n        if (62 === next) return scanPunctuator('>>');\n        return scanPunctuator('>');\n\n      case 60: // <\n        if (60 === next) return scanPunctuator('<<');\n        if (61 === next) return scanPunctuator('<=');\n        return scanPunctuator('<');\n\n      case 126: // ~\n        if (61 === next) return scanPunctuator('~=');\n        return scanPunctuator('~');\n\n      case 58: // :\n        if (58 === next) return scanPunctuator('::');\n        return scanPunctuator(':');\n\n      case 91: // [\n        // Check for a multiline string, they begin with [= or [[\n        if (91 === next || 61 === next) return scanLongStringLiteral();\n        return scanPunctuator('[');\n\n      case 47: // /\n        // Check for integer division op (//)\n        if (47 === next) return scanPunctuator('//');\n        return scanPunctuator('/');\n\n      // * ^ % , { } ] ( ) ; & # - + |\n      case 42: case 94: case 37: case 44: case 123: case 124: case 125:\n      case 93: case 40: case 41: case 59: case 38: case 35: case 45: case 43:\n        return scanPunctuator(input.charAt(index));\n    }\n\n    return unexpected(input.charAt(index));\n  }\n\n  // Whitespace has no semantic meaning in lua so simply skip ahead while\n  // tracking the encounted newlines. Any kind of eol sequence is counted as a\n  // single line.\n\n  function consumeEOL() {\n    var charCode = input.charCodeAt(index)\n      , peekCharCode = input.charCodeAt(index + 1);\n\n    if (isLineTerminator(charCode)) {\n      // Count \\n\\r and \\r\\n as one newline.\n      if (10 === charCode && 13 === peekCharCode) index++;\n      if (13 === charCode && 10 === peekCharCode) index++;\n      line++;\n      lineStart = ++index;\n\n      return true;\n    }\n    return false;\n  }\n\n  function skipWhiteSpace() {\n    while (index < length) {\n      var charCode = input.charCodeAt(index);\n      if (isWhiteSpace(charCode)) {\n        index++;\n      } else if (!consumeEOL()) {\n        break;\n      }\n    }\n  }\n\n  // Identifiers, keywords, booleans and nil all look the same syntax wise. We\n  // simply go through them one by one and defaulting to an identifier if no\n  // previous case matched.\n\n  function scanIdentifierOrKeyword() {\n    var value, type;\n\n    // Slicing the input string is prefered before string concatenation in a\n    // loop for performance reasons.\n    while (isIdentifierPart(input.charCodeAt(++index)));\n    value = input.slice(tokenStart, index);\n\n    // Decide on the token type and possibly cast the value.\n    if (isKeyword(value)) {\n      type = Keyword;\n    } else if ('true' === value || 'false' === value) {\n      type = BooleanLiteral;\n      value = ('true' === value);\n    } else if ('nil' === value) {\n      type = NilLiteral;\n      value = null;\n    } else {\n      type = Identifier;\n    }\n\n    return {\n        type: type\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Once a punctuator reaches this function it should already have been\n  // validated so we simply return it as a token.\n\n  function scanPunctuator(value) {\n    index += value.length;\n    return {\n        type: Punctuator\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // A vararg literal consists of three dots.\n\n  function scanVarargLiteral() {\n    index += 3;\n    return {\n        type: VarargLiteral\n      , value: '...'\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Find the string literal by matching the delimiter marks used.\n\n  function scanStringLiteral() {\n    var delimiter = input.charCodeAt(index++)\n      , stringStart = index\n      , string = ''\n      , charCode;\n\n    while (index < length) {\n      charCode = input.charCodeAt(index++);\n      if (delimiter === charCode) break;\n      if (92 === charCode) { // \\\n        string += input.slice(stringStart, index - 1) + readEscapeSequence();\n        stringStart = index;\n      }\n      // EOF or `\\n` terminates a string literal. If we haven't found the\n      // ending delimiter by now, raise an exception.\n      else if (index >= length || isLineTerminator(charCode)) {\n        string += input.slice(stringStart, index - 1);\n        raise({}, errors.unfinishedString, string + String.fromCharCode(charCode));\n      }\n    }\n    string += input.slice(stringStart, index - 1);\n\n    return {\n        type: StringLiteral\n      , value: string\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Expect a multiline string literal and return it as a regular string\n  // literal, if it doesn't validate into a valid multiline string, throw an\n  // exception.\n\n  function scanLongStringLiteral() {\n    var string = readLongString();\n    // Fail if it's not a multiline literal.\n    if (false === string) raise(token, errors.expected, '[', token.value);\n\n    return {\n        type: StringLiteral\n      , value: string\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Numeric literals will be returned as floating-point numbers instead of\n  // strings. The raw value should be retrieved from slicing the input string\n  // later on in the process.\n  //\n  // If a hexadecimal number is encountered, it will be converted.\n\n  function scanNumericLiteral() {\n    var character = input.charAt(index)\n      , next = input.charAt(index + 1);\n\n    var value = ('0' === character && 'xX'.indexOf(next || null) >= 0) ?\n      readHexLiteral() : readDecLiteral();\n\n    return {\n        type: NumericLiteral\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Lua hexadecimals have an optional fraction part and an optional binary\n  // exoponent part. These are not included in JavaScript so we will compute\n  // all three parts separately and then sum them up at the end of the function\n  // with the following algorithm.\n  //\n  //     Digit := toDec(digit)\n  //     Fraction := toDec(fraction) / 16 ^ fractionCount\n  //     BinaryExp := 2 ^ binaryExp\n  //     Number := ( Digit + Fraction ) * BinaryExp\n\n  function readHexLiteral() {\n    var fraction = 0 // defaults to 0 as it gets summed\n      , binaryExponent = 1 // defaults to 1 as it gets multiplied\n      , binarySign = 1 // positive\n      , digit, fractionStart, exponentStart, digitStart;\n\n    digitStart = index += 2; // Skip 0x part\n\n    // A minimum of one hex digit is required.\n    if (!isHexDigit(input.charCodeAt(index)))\n      raise({}, errors.malformedNumber, input.slice(tokenStart, index));\n\n    while (isHexDigit(input.charCodeAt(index))) index++;\n    // Convert the hexadecimal digit to base 10.\n    digit = parseInt(input.slice(digitStart, index), 16);\n\n    // Fraction part i optional.\n    if ('.' === input.charAt(index)) {\n      fractionStart = ++index;\n\n      while (isHexDigit(input.charCodeAt(index))) index++;\n      fraction = input.slice(fractionStart, index);\n\n      // Empty fraction parts should default to 0, others should be converted\n      // 0.x form so we can use summation at the end.\n      fraction = (fractionStart === index) ? 0\n        : parseInt(fraction, 16) / Math.pow(16, index - fractionStart);\n    }\n\n    // Binary exponents are optional\n    if ('pP'.indexOf(input.charAt(index) || null) >= 0) {\n      index++;\n\n      // Sign part is optional and defaults to 1 (positive).\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0)\n        binarySign = ('+' === input.charAt(index++)) ? 1 : -1;\n\n      exponentStart = index;\n\n      // The binary exponent sign requires a decimal digit.\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise({}, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) index++;\n      binaryExponent = input.slice(exponentStart, index);\n\n      // Calculate the binary exponent of the number.\n      binaryExponent = Math.pow(2, binaryExponent * binarySign);\n    }\n\n    return (digit + fraction) * binaryExponent;\n  }\n\n  // Decimal numbers are exactly the same in Lua and in JavaScript, because of\n  // this we check where the token ends and then parse it with native\n  // functions.\n\n  function readDecLiteral() {\n    while (isDecDigit(input.charCodeAt(index))) index++;\n    // Fraction part is optional\n    if ('.' === input.charAt(index)) {\n      index++;\n      // Fraction part defaults to 0\n      while (isDecDigit(input.charCodeAt(index))) index++;\n    }\n    // Exponent part is optional.\n    if ('eE'.indexOf(input.charAt(index) || null) >= 0) {\n      index++;\n      // Sign part is optional.\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0) index++;\n      // An exponent is required to contain at least one decimal digit.\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise({}, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) index++;\n    }\n\n    return parseFloat(input.slice(tokenStart, index));\n  }\n\n\n  // Translate escape sequences to the actual characters.\n\n  function readEscapeSequence() {\n    var sequenceStart = index;\n    switch (input.charAt(index)) {\n      // Lua allow the following escape sequences.\n      // We don't escape the bell sequence.\n      case 'n': index++; return '\\n';\n      case 'r': index++; return '\\r';\n      case 't': index++; return '\\t';\n      case 'v': index++; return '\\x0B';\n      case 'b': index++; return '\\b';\n      case 'f': index++; return '\\f';\n      // Skips the following span of white-space.\n      case 'z': index++; skipWhiteSpace(); return '';\n      // Byte representation should for now be returned as is.\n      case 'x':\n        // \\xXX, where XX is a sequence of exactly two hexadecimal digits\n        if (isHexDigit(input.charCodeAt(index + 1)) &&\n            isHexDigit(input.charCodeAt(index + 2))) {\n          index += 3;\n          // Return it as is, without translating the byte.\n          return '\\\\' + input.slice(sequenceStart, index);\n        }\n        return '\\\\' + input.charAt(index++);\n      default:\n        // \\ddd, where ddd is a sequence of up to three decimal digits.\n        if (isDecDigit(input.charCodeAt(index))) {\n          while (isDecDigit(input.charCodeAt(++index)));\n          return '\\\\' + input.slice(sequenceStart, index);\n        }\n        // Simply return the \\ as is, it's not escaping any sequence.\n        return input.charAt(index++);\n    }\n  }\n\n  // Comments begin with -- after which it will be decided if they are\n  // multiline comments or not.\n  //\n  // The multiline functionality works the exact same way as with string\n  // literals so we reuse the functionality.\n\n  function scanComment() {\n    tokenStart = index;\n    index += 2; // --\n\n    var character = input.charAt(index)\n      , content = ''\n      , isLong = false\n      , commentStart = index\n      , lineStartComment = lineStart\n      , lineComment = line;\n\n    if ('[' === character) {\n      content = readLongString();\n      // This wasn't a multiline comment after all.\n      if (false === content) content = character;\n      else isLong = true;\n    }\n    // Scan until next line as long as it's not a multiline comment.\n    if (!isLong) {\n      while (index < length) {\n        if (isLineTerminator(input.charCodeAt(index))) break;\n        index++;\n      }\n      if (options.comments) content = input.slice(commentStart, index);\n    }\n\n    if (options.comments) {\n      var node = ast.comment(content, input.slice(tokenStart, index));\n\n      // `Marker`s depend on tokens available in the parser and as comments are\n      // intercepted in the lexer all location data is set manually.\n      if (options.locations) {\n        node.loc = {\n            start: { line: lineComment, column: tokenStart - lineStartComment }\n          , end: { line: line, column: index - lineStart }\n        };\n      }\n      if (options.ranges) {\n        node.range = [tokenStart, index];\n      }\n      if (options.onCreateNode) options.onCreateNode(node);\n      comments.push(node);\n    }\n  }\n\n  // Read a multiline string by calculating the depth of `=` characters and\n  // then appending until an equal depth is found.\n\n  function readLongString() {\n    var level = 0\n      , content = ''\n      , terminator = false\n      , character, stringStart;\n\n    index++; // [\n\n    // Calculate the depth of the comment.\n    while ('=' === input.charAt(index + level)) level++;\n    // Exit, this is not a long string afterall.\n    if ('[' !== input.charAt(index + level)) return false;\n\n    index += level + 1;\n\n    // If the first character is a newline, ignore it and begin on next line.\n    if (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n\n    stringStart = index;\n    while (index < length) {\n      // To keep track of line numbers run the `consumeEOL()` which increments\n      // its counter.\n      if (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n\n      character = input.charAt(index++);\n\n      // Once the delimiter is found, iterate through the depth count and see\n      // if it matches.\n      if (']' === character) {\n        terminator = true;\n        for (var i = 0; i < level; i++) {\n          if ('=' !== input.charAt(index + i)) terminator = false;\n        }\n        if (']' !== input.charAt(index + level)) terminator = false;\n      }\n\n      // We reached the end of the multiline string. Get out now.\n      if (terminator) break;\n    }\n    content += input.slice(stringStart, index - 1);\n    index += level + 1;\n\n    return content;\n  }\n\n  // ## Lex functions and helpers.\n\n  // Read the next token.\n  //\n  // This is actually done by setting the current token to the lookahead and\n  // reading in the new lookahead token.\n\n  function next() {\n    previousToken = token;\n    token = lookahead;\n    lookahead = lex();\n  }\n\n  // Consume a token if its value matches. Once consumed or not, return the\n  // success of the operation.\n\n  function consume(value) {\n    if (value === token.value) {\n      next();\n      return true;\n    }\n    return false;\n  }\n\n  // Expect the next token value to match. If not, throw an exception.\n\n  function expect(value) {\n    if (value === token.value) next();\n    else raise(token, errors.expected, value, token.value);\n  }\n\n  // ### Validation functions\n\n  function isWhiteSpace(charCode) {\n    return 9 === charCode || 32 === charCode || 0xB === charCode || 0xC === charCode;\n  }\n\n  function isLineTerminator(charCode) {\n    return 10 === charCode || 13 === charCode;\n  }\n\n  function isDecDigit(charCode) {\n    return charCode >= 48 && charCode <= 57;\n  }\n\n  function isHexDigit(charCode) {\n    return (charCode >= 48 && charCode <= 57) || (charCode >= 97 && charCode <= 102) || (charCode >= 65 && charCode <= 70);\n  }\n\n  // From [Lua 5.2](http://www.lua.org/manual/5.2/manual.html#8.1) onwards\n  // identifiers cannot use locale-dependet letters.\n\n  function isIdentifierStart(charCode) {\n    return (charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode;\n  }\n\n  function isIdentifierPart(charCode) {\n    return (charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode || (charCode >= 48 && charCode <= 57);\n  }\n\n  // [3.1 Lexical Conventions](http://www.lua.org/manual/5.2/manual.html#3.1)\n  //\n  // `true`, `false` and `nil` will not be considered keywords, but literals.\n\n  function isKeyword(id) {\n    switch (id.length) {\n      case 2:\n        return 'do' === id || 'if' === id || 'in' === id || 'or' === id;\n      case 3:\n        return 'and' === id || 'end' === id || 'for' === id || 'not' === id;\n      case 4:\n        return 'else' === id || 'goto' === id || 'then' === id;\n      case 5:\n        return 'break' === id || 'local' === id || 'until' === id || 'while' === id;\n      case 6:\n        return 'elseif' === id || 'repeat' === id || 'return' === id;\n      case 8:\n        return 'function' === id;\n    }\n    return false;\n  }\n\n  function isUnary(token) {\n    if (Punctuator === token.type) return '#-~'.indexOf(token.value) >= 0;\n    if (Keyword === token.type) return 'not' === token.value;\n    return false;\n  }\n\n  // @TODO this needs to be rethought.\n  function isCallExpression(expression) {\n    switch (expression.type) {\n      case 'CallExpression':\n      case 'TableCallExpression':\n      case 'StringCallExpression':\n        return true;\n    }\n    return false;\n  }\n\n  // Check if the token syntactically closes a block.\n\n  function isBlockFollow(token) {\n    if (EOF === token.type) return true;\n    if (Keyword !== token.type) return false;\n    switch (token.value) {\n      case 'else': case 'elseif':\n      case 'end': case 'until':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // Scope\n  // -----\n\n  // Store each block scope as a an array of identifier names. Each scope is\n  // stored in an FILO-array.\n  var scopes\n    // The current scope index\n    , scopeDepth\n    // A list of all global identifier nodes.\n    , globals;\n\n  // Create a new scope inheriting all declarations from the previous scope.\n  function createScope() {\n    var scope = Array.apply(null, scopes[scopeDepth++]);\n    scopes.push(scope);\n    if (options.onCreateScope) options.onCreateScope();\n  }\n\n  // Exit and remove the current scope.\n  function destroyScope() {\n    var scope = scopes.pop();\n    scopeDepth--;\n    if (options.onDestroyScope) options.onDestroyScope();\n  }\n\n  // Add identifier name to the current scope if it doesnt already exist.\n  function scopeIdentifierName(name) {\n    if (-1 !== indexOf(scopes[scopeDepth], name)) return;\n    scopes[scopeDepth].push(name);\n  }\n\n  // Add identifier to the current scope\n  function scopeIdentifier(node) {\n    scopeIdentifierName(node.name);\n    attachScope(node, true);\n  }\n\n  // Attach scope information to node. If the node is global, store it in the\n  // globals array so we can return the information to the user.\n  function attachScope(node, isLocal) {\n    if (!isLocal && -1 === indexOfObject(globals, 'name', node.name))\n      globals.push(node);\n\n    node.isLocal = isLocal;\n  }\n\n  // Is the identifier name available in this scope.\n  function scopeHasName(name) {\n    return (-1 !== indexOf(scopes[scopeDepth], name));\n  }\n\n  // Location tracking\n  // -----------------\n  //\n  // Locations are stored in FILO-array as a `Marker` object consisting of both\n  // `loc` and `range` data. Once a `Marker` is popped off the list an end\n  // location is added and the data is attached to a syntax node.\n\n  var locations = []\n    , trackLocations;\n\n  function createLocationMarker() {\n    return new Marker(token);\n  }\n\n  function Marker(token) {\n    if (options.locations) {\n      this.loc = {\n          start: {\n            line: token.line\n          , column: token.range[0] - token.lineStart\n        }\n        , end: {\n            line: 0\n          , column: 0\n        }\n      };\n    }\n    if (options.ranges) this.range = [token.range[0], 0];\n  }\n\n  // Complete the location data stored in the `Marker` by adding the location\n  // of the *previous token* as an end location.\n  Marker.prototype.complete = function() {\n    if (options.locations) {\n      this.loc.end.line = previousToken.line;\n      this.loc.end.column = previousToken.range[1] - previousToken.lineStart;\n    }\n    if (options.ranges) {\n      this.range[1] = previousToken.range[1];\n    }\n  };\n\n  // Create a new `Marker` and add it to the FILO-array.\n  function markLocation() {\n    if (trackLocations) locations.push(createLocationMarker());\n  }\n\n  // Push an arbitrary `Marker` object onto the FILO-array.\n  function pushLocation(marker) {\n    if (trackLocations) locations.push(marker);\n  }\n\n  // Parse functions\n  // ---------------\n\n  // Chunk is the main program object. Syntactically it's the same as a block.\n  //\n  //     chunk ::= block\n\n  function parseChunk() {\n    next();\n    markLocation();\n    if (options.scope) createScope();\n    var body = parseBlock();\n    if (options.scope) destroyScope();\n    if (EOF !== token.type) unexpected(token);\n    // If the body is empty no previousToken exists when finishNode runs.\n    if (trackLocations && !body.length) previousToken = token;\n    return finishNode(ast.chunk(body));\n  }\n\n  // A block contains a list of statements with an optional return statement\n  // as its last statement.\n  //\n  //     block ::= {stat} [retstat]\n\n  function parseBlock(terminator) {\n    var block = []\n      , statement;\n\n    while (!isBlockFollow(token)) {\n      // Return has to be the last statement in a block.\n      if ('return' === token.value) {\n        block.push(parseStatement());\n        break;\n      }\n      statement = parseStatement();\n      // Statements are only added if they are returned, this allows us to\n      // ignore some statements, such as EmptyStatement.\n      if (statement) block.push(statement);\n    }\n\n    // Doesn't really need an ast node\n    return block;\n  }\n\n  // There are two types of statements, simple and compound.\n  //\n  //     statement ::= break | goto | do | while | repeat | return\n  //          | if | for | function | local | label | assignment\n  //          | functioncall | ';'\n\n  function parseStatement() {\n    markLocation();\n    if (Keyword === token.type) {\n      switch (token.value) {\n        case 'local':    next(); return parseLocalStatement();\n        case 'if':       next(); return parseIfStatement();\n        case 'return':   next(); return parseReturnStatement();\n        case 'function': next();\n          var name = parseFunctionName();\n          return parseFunctionDeclaration(name);\n        case 'while':    next(); return parseWhileStatement();\n        case 'for':      next(); return parseForStatement();\n        case 'repeat':   next(); return parseRepeatStatement();\n        case 'break':    next(); return parseBreakStatement();\n        case 'do':       next(); return parseDoStatement();\n        case 'goto':     next(); return parseGotoStatement();\n      }\n    }\n\n    if (Punctuator === token.type) {\n      if (consume('::')) return parseLabelStatement();\n    }\n    // Assignments memorizes the location and pushes it manually for wrapper\n    // nodes. Additionally empty `;` statements should not mark a location.\n    if (trackLocations) locations.pop();\n\n    // When a `;` is encounted, simply eat it without storing it.\n    if (consume(';')) return;\n\n    return parseAssignmentOrCallStatement();\n  }\n\n  // ## Statements\n\n  //     label ::= '::' Name '::'\n\n  function parseLabelStatement() {\n    var name = token.value\n      , label = parseIdentifier();\n\n    if (options.scope) {\n      scopeIdentifierName('::' + name + '::');\n      attachScope(label, true);\n    }\n\n    expect('::');\n    return finishNode(ast.labelStatement(label));\n  }\n\n  //     break ::= 'break'\n\n  function parseBreakStatement() {\n    return finishNode(ast.breakStatement());\n  }\n\n  //     goto ::= 'goto' Name\n\n  function parseGotoStatement() {\n    var name = token.value\n      , label = parseIdentifier();\n\n    return finishNode(ast.gotoStatement(label));\n  }\n\n  //     do ::= 'do' block 'end'\n\n  function parseDoStatement() {\n    if (options.scope) createScope();\n    var body = parseBlock();\n    if (options.scope) destroyScope();\n    expect('end');\n    return finishNode(ast.doStatement(body));\n  }\n\n  //     while ::= 'while' exp 'do' block 'end'\n\n  function parseWhileStatement() {\n    var condition = parseExpectedExpression();\n    expect('do');\n    if (options.scope) createScope();\n    var body = parseBlock();\n    if (options.scope) destroyScope();\n    expect('end');\n    return finishNode(ast.whileStatement(condition, body));\n  }\n\n  //     repeat ::= 'repeat' block 'until' exp\n\n  function parseRepeatStatement() {\n    if (options.scope) createScope();\n    var body = parseBlock();\n    expect('until');\n    var condition = parseExpectedExpression();\n    if (options.scope) destroyScope();\n    return finishNode(ast.repeatStatement(condition, body));\n  }\n\n  //     retstat ::= 'return' [exp {',' exp}] [';']\n\n  function parseReturnStatement() {\n    var expressions = [];\n\n    if ('end' !== token.value) {\n      var expression = parseExpression();\n      if (null != expression) expressions.push(expression);\n      while (consume(',')) {\n        expression = parseExpectedExpression();\n        expressions.push(expression);\n      }\n      consume(';'); // grammar tells us ; is optional here.\n    }\n    return finishNode(ast.returnStatement(expressions));\n  }\n\n  //     if ::= 'if' exp 'then' block {elif} ['else' block] 'end'\n  //     elif ::= 'elseif' exp 'then' block\n\n  function parseIfStatement() {\n    var clauses = []\n      , condition\n      , body\n      , marker;\n\n    // IfClauses begin at the same location as the parent IfStatement.\n    // It ends at the start of `end`, `else`, or `elseif`.\n    if (trackLocations) {\n      marker = locations[locations.length - 1];\n      locations.push(marker);\n    }\n    condition = parseExpectedExpression();\n    expect('then');\n    if (options.scope) createScope();\n    body = parseBlock();\n    if (options.scope) destroyScope();\n    clauses.push(finishNode(ast.ifClause(condition, body)));\n\n    if (trackLocations) marker = createLocationMarker();\n    while (consume('elseif')) {\n      pushLocation(marker);\n      condition = parseExpectedExpression();\n      expect('then');\n      if (options.scope) createScope();\n      body = parseBlock();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.elseifClause(condition, body)));\n      if (trackLocations) marker = createLocationMarker();\n    }\n\n    if (consume('else')) {\n      // Include the `else` in the location of ElseClause.\n      if (trackLocations) {\n        marker = new Marker(previousToken);\n        locations.push(marker);\n      }\n      if (options.scope) createScope();\n      body = parseBlock();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.elseClause(body)));\n    }\n\n    expect('end');\n    return finishNode(ast.ifStatement(clauses));\n  }\n\n  // There are two types of for statements, generic and numeric.\n  //\n  //     for ::= Name '=' exp ',' exp [',' exp] 'do' block 'end'\n  //     for ::= namelist 'in' explist 'do' block 'end'\n  //     namelist ::= Name {',' Name}\n  //     explist ::= exp {',' exp}\n\n  function parseForStatement() {\n    var variable = parseIdentifier()\n      , body;\n\n    // The start-identifier is local.\n\n    if (options.scope) {\n      createScope();\n      scopeIdentifier(variable);\n    }\n\n    // If the first expression is followed by a `=` punctuator, this is a\n    // Numeric For Statement.\n    if (consume('=')) {\n      // Start expression\n      var start = parseExpectedExpression();\n      expect(',');\n      // End expression\n      var end = parseExpectedExpression();\n      // Optional step expression\n      var step = consume(',') ? parseExpectedExpression() : null;\n\n      expect('do');\n      body = parseBlock();\n      expect('end');\n      if (options.scope) destroyScope();\n\n      return finishNode(ast.forNumericStatement(variable, start, end, step, body));\n    }\n    // If not, it's a Generic For Statement\n    else {\n      // The namelist can contain one or more identifiers.\n      var variables = [variable];\n      while (consume(',')) {\n        variable = parseIdentifier();\n        // Each variable in the namelist is locally scoped.\n        if (options.scope) scopeIdentifier(variable);\n        variables.push(variable);\n      }\n      expect('in');\n      var iterators = [];\n\n      // One or more expressions in the explist.\n      do {\n        var expression = parseExpectedExpression();\n        iterators.push(expression);\n      } while (consume(','));\n\n      expect('do');\n      body = parseBlock();\n      expect('end');\n      if (options.scope) destroyScope();\n\n      return finishNode(ast.forGenericStatement(variables, iterators, body));\n    }\n  }\n\n  // Local statements can either be variable assignments or function\n  // definitions. If a function definition is found, it will be delegated to\n  // `parseFunctionDeclaration()` with the isLocal flag.\n  //\n  // This AST structure might change into a local assignment with a function\n  // child.\n  //\n  //     local ::= 'local' 'function' Name funcdecl\n  //        | 'local' Name {',' Name} ['=' exp {',' exp}]\n\n  function parseLocalStatement() {\n    var name;\n\n    if (Identifier === token.type) {\n      var variables = []\n        , init = [];\n\n      do {\n        name = parseIdentifier();\n\n        variables.push(name);\n      } while (consume(','));\n\n      if (consume('=')) {\n        do {\n          var expression = parseExpectedExpression();\n          init.push(expression);\n        } while (consume(','));\n      }\n\n      // Declarations doesn't exist before the statement has been evaluated.\n      // Therefore assignments can't use their declarator. And the identifiers\n      // shouldn't be added to the scope until the statement is complete.\n      if (options.scope) {\n        for (var i = 0, l = variables.length; i < l; i++) {\n          scopeIdentifier(variables[i]);\n        }\n      }\n\n      return finishNode(ast.localStatement(variables, init));\n    }\n    if (consume('function')) {\n      name = parseIdentifier();\n\n      if (options.scope) {\n        scopeIdentifier(name);\n        createScope();\n      }\n\n      // MemberExpressions are not allowed in local function statements.\n      return parseFunctionDeclaration(name, true);\n    } else {\n      raiseUnexpectedToken('<name>', token);\n    }\n  }\n\n  function validateVar(node) {\n    // @TODO we need something not dependent on the exact AST used. see also isCallExpression()\n    if (node.inParens || (['Identifier', 'MemberExpression', 'IndexExpression'].indexOf(node.type) === -1)) {\n      raise(token, errors.invalidVar, token.value);\n    }\n  }\n\n  //     assignment ::= varlist '=' explist\n  //     var ::= Name | prefixexp '[' exp ']' | prefixexp '.' Name\n  //     varlist ::= var {',' var}\n  //     explist ::= exp {',' exp}\n  //\n  //     call ::= callexp\n  //     callexp ::= prefixexp args | prefixexp ':' Name args\n\n  function parseAssignmentOrCallStatement() {\n    // Keep a reference to the previous token for better error messages in case\n    // of invalid statement\n    var previous = token\n      , expression, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n    expression = parsePrefixExpression();\n\n    if (null == expression) return unexpected(token);\n    if (',='.indexOf(token.value) >= 0) {\n      var variables = [expression]\n        , init = []\n        , exp;\n\n      validateVar(expression);\n      while (consume(',')) {\n        exp = parsePrefixExpression();\n        if (null == exp) raiseUnexpectedToken('<expression>', token);\n        validateVar(exp);\n        variables.push(exp);\n      }\n      expect('=');\n      do {\n        exp = parseExpectedExpression();\n        init.push(exp);\n      } while (consume(','));\n\n      pushLocation(marker);\n      return finishNode(ast.assignmentStatement(variables, init));\n    }\n    if (isCallExpression(expression)) {\n      pushLocation(marker);\n      return finishNode(ast.callStatement(expression));\n    }\n    // The prefix expression was neither part of an assignment or a\n    // callstatement, however as it was valid it's been consumed, so raise\n    // the exception on the previous token to provide a helpful message.\n    return unexpected(previous);\n  }\n\n\n\n  // ### Non-statements\n\n  //     Identifier ::= Name\n\n  function parseIdentifier() {\n    markLocation();\n    var identifier = token.value;\n    if (Identifier !== token.type) raiseUnexpectedToken('<name>', token);\n    next();\n    return finishNode(ast.identifier(identifier));\n  }\n\n  // Parse the functions parameters and body block. The name should already\n  // have been parsed and passed to this declaration function. By separating\n  // this we allow for anonymous functions in expressions.\n  //\n  // For local functions there's a boolean parameter which needs to be set\n  // when parsing the declaration.\n  //\n  //     funcdecl ::= '(' [parlist] ')' block 'end'\n  //     parlist ::= Name {',' Name} | [',' '...'] | '...'\n\n  function parseFunctionDeclaration(name, isLocal) {\n    var parameters = [];\n    expect('(');\n\n    // The declaration has arguments\n    if (!consume(')')) {\n      // Arguments are a comma separated list of identifiers, optionally ending\n      // with a vararg.\n      while (true) {\n        if (Identifier === token.type) {\n          var parameter = parseIdentifier();\n          // Function parameters are local.\n          if (options.scope) scopeIdentifier(parameter);\n\n          parameters.push(parameter);\n\n          if (consume(',')) continue;\n          else if (consume(')')) break;\n        }\n        // No arguments are allowed after a vararg.\n        else if (VarargLiteral === token.type) {\n          parameters.push(parsePrimaryExpression());\n          expect(')');\n          break;\n        } else {\n          raiseUnexpectedToken('<name> or \\'...\\'', token);\n        }\n      }\n    }\n\n    var body = parseBlock();\n    expect('end');\n    if (options.scope) destroyScope();\n\n    isLocal = isLocal || false;\n    return finishNode(ast.functionStatement(name, parameters, isLocal, body));\n  }\n\n  // Parse the function name as identifiers and member expressions.\n  //\n  //     Name {'.' Name} [':' Name]\n\n  function parseFunctionName() {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n    base = parseIdentifier();\n\n    if (options.scope) {\n      attachScope(base, scopeHasName(base.name));\n      createScope();\n    }\n\n    while (consume('.')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      base = finishNode(ast.memberExpression(base, '.', name));\n    }\n\n    if (consume(':')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      base = finishNode(ast.memberExpression(base, ':', name));\n      if (options.scope) scopeIdentifierName('self');\n    }\n\n    return base;\n  }\n\n  //     tableconstructor ::= '{' [fieldlist] '}'\n  //     fieldlist ::= field {fieldsep field} fieldsep\n  //     field ::= '[' exp ']' '=' exp | Name = 'exp' | exp\n  //\n  //     fieldsep ::= ',' | ';'\n\n  function parseTableConstructor() {\n    var fields = []\n      , key, value;\n\n    while (true) {\n      markLocation();\n      if (Punctuator === token.type && consume('[')) {\n        key = parseExpectedExpression();\n        expect(']');\n        expect('=');\n        value = parseExpectedExpression();\n        fields.push(finishNode(ast.tableKey(key, value)));\n      } else if (Identifier === token.type) {\n        if ('=' === lookahead.value) {\n          key = parseIdentifier();\n          next();\n          value = parseExpectedExpression();\n          fields.push(finishNode(ast.tableKeyString(key, value)));\n        } else {\n          value = parseExpectedExpression();\n          fields.push(finishNode(ast.tableValue(value)));\n        }\n      } else {\n        if (null == (value = parseExpression())) {\n          locations.pop();\n          break;\n        }\n        fields.push(finishNode(ast.tableValue(value)));\n      }\n      if (',;'.indexOf(token.value) >= 0) {\n        next();\n        continue;\n      }\n      break;\n    }\n    expect('}');\n    return finishNode(ast.tableConstructorExpression(fields));\n  }\n\n  // Expression parser\n  // -----------------\n  //\n  // Expressions are evaluated and always return a value. If nothing is\n  // matched null will be returned.\n  //\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\n  //\n  //     primary ::= nil | false | true | Number | String | '...'\n  //          | functiondef | tableconstructor\n  //\n  //     prefixexp ::= (Name | '(' exp ')' ) { '[' exp ']'\n  //          | '.' Name | ':' Name args | args }\n  //\n\n  function parseExpression() {\n    var expression = parseSubExpression(0);\n    return expression;\n  }\n\n  // Parse an expression expecting it to be valid.\n\n  function parseExpectedExpression() {\n    var expression = parseExpression();\n    if (null == expression) raiseUnexpectedToken('<expression>', token);\n    else return expression;\n  }\n\n\n  // Return the precedence priority of the operator.\n  //\n  // As unary `-` can't be distinguished from binary `-`, unary precedence\n  // isn't described in this table but in `parseSubExpression()` itself.\n  //\n  // As this function gets hit on every expression it's been optimized due to\n  // the expensive CompareICStub which took ~8% of the parse time.\n\n  function binaryPrecedence(operator) {\n    var charCode = operator.charCodeAt(0)\n      , length = operator.length;\n\n    if (1 === length) {\n      switch (charCode) {\n        case 94: return 12; // ^\n        case 42: case 47: case 37: return 10; // * / %\n        case 43: case 45: return 9; // + -\n        case 38: return 6; // &\n        case 126: return 5; // ~\n        case 124: return 4; // |\n        case 60: case 62: return 3; // < >\n      }\n    } else if (2 === length) {\n      switch (charCode) {\n        case 47: return 10; // //\n        case 46: return 8; // ..\n        case 60: case 62:\n            if('<<' === operator || '>>' === operator) return 7; // << >>\n            return 3; // <= >=\n        case 61: case 126: return 3; // == ~=\n        case 111: return 1; // or\n      }\n    } else if (97 === charCode && 'and' === operator) return 2;\n    return 0;\n  }\n\n  // Implement an operator-precedence parser to handle binary operator\n  // precedence.\n  //\n  // We use this algorithm because it's compact, it's fast and Lua core uses\n  // the same so we can be sure our expressions are parsed in the same manner\n  // without excessive amounts of tests.\n  //\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\n\n  function parseSubExpression(minPrecedence) {\n    var operator = token.value\n    // The left-hand side in binary operations.\n      , expression, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    // UnaryExpression\n    if (isUnary(token)) {\n      markLocation();\n      next();\n      var argument = parseSubExpression(10);\n      if (argument == null) raiseUnexpectedToken('<expression>', token);\n      expression = finishNode(ast.unaryExpression(operator, argument));\n    }\n    if (null == expression) {\n      // PrimaryExpression\n      expression = parsePrimaryExpression();\n\n      // PrefixExpression\n      if (null == expression) {\n        expression = parsePrefixExpression();\n      }\n    }\n    // This is not a valid left hand expression.\n    if (null == expression) return null;\n\n    var precedence;\n    while (true) {\n      operator = token.value;\n\n      precedence = (Punctuator === token.type || Keyword === token.type) ?\n        binaryPrecedence(operator) : 0;\n\n      if (precedence === 0 || precedence <= minPrecedence) break;\n      // Right-hand precedence operators\n      if ('^' === operator || '..' === operator) precedence--;\n      next();\n      var right = parseSubExpression(precedence);\n      if (null == right) raiseUnexpectedToken('<expression>', token);\n      // Push in the marker created before the loop to wrap its entirety.\n      if (trackLocations) locations.push(marker);\n      expression = finishNode(ast.binaryExpression(operator, expression, right));\n\n    }\n    return expression;\n  }\n\n  //     prefixexp ::= prefix {suffix}\n  //     prefix ::= Name | '(' exp ')'\n  //     suffix ::= '[' exp ']' | '.' Name | ':' Name args | args\n  //\n  //     args ::= '(' [explist] ')' | tableconstructor | String\n\n  function parsePrefixExpression() {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    // The prefix\n    if (Identifier === token.type) {\n      name = token.value;\n      base = parseIdentifier();\n      // Set the parent scope.\n      if (options.scope) attachScope(base, scopeHasName(name));\n    } else if (consume('(')) {\n      base = parseExpectedExpression();\n      expect(')');\n      base.inParens = true; // XXX: quick and dirty. needed for validateVar\n    } else {\n      return null;\n    }\n\n    // The suffix\n    var expression, identifier;\n    while (true) {\n      if (Punctuator === token.type) {\n        switch (token.value) {\n          case '[':\n            pushLocation(marker);\n            next();\n            expression = parseExpectedExpression();\n            base = finishNode(ast.indexExpression(base, expression));\n            expect(']');\n            break;\n          case '.':\n            pushLocation(marker);\n            next();\n            identifier = parseIdentifier();\n            base = finishNode(ast.memberExpression(base, '.', identifier));\n            break;\n          case ':':\n            pushLocation(marker);\n            next();\n            identifier = parseIdentifier();\n            base = finishNode(ast.memberExpression(base, ':', identifier));\n            // Once a : is found, this has to be a CallExpression, otherwise\n            // throw an error.\n            pushLocation(marker);\n            base = parseCallExpression(base);\n            break;\n          case '(': case '{': // args\n            pushLocation(marker);\n            base = parseCallExpression(base);\n            break;\n          default:\n            return base;\n        }\n      } else if (StringLiteral === token.type) {\n        pushLocation(marker);\n        base = parseCallExpression(base);\n      } else {\n        break;\n      }\n    }\n\n    return base;\n  }\n\n  //     args ::= '(' [explist] ')' | tableconstructor | String\n\n  function parseCallExpression(base) {\n    if (Punctuator === token.type) {\n      switch (token.value) {\n        case '(':\n          next();\n\n          // List of expressions\n          var expressions = [];\n          var expression = parseExpression();\n          if (null != expression) expressions.push(expression);\n          while (consume(',')) {\n            expression = parseExpectedExpression();\n            expressions.push(expression);\n          }\n\n          expect(')');\n          return finishNode(ast.callExpression(base, expressions));\n\n        case '{':\n          markLocation();\n          next();\n          var table = parseTableConstructor();\n          return finishNode(ast.tableCallExpression(base, table));\n      }\n    } else if (StringLiteral === token.type) {\n      return finishNode(ast.stringCallExpression(base, parsePrimaryExpression()));\n    }\n\n    raiseUnexpectedToken('function arguments', token);\n  }\n\n  //     primary ::= String | Numeric | nil | true | false\n  //          | functiondef | tableconstructor | '...'\n\n  function parsePrimaryExpression() {\n    var literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral\n      , value = token.value\n      , type = token.type\n      , marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    if (type & literals) {\n      pushLocation(marker);\n      var raw = input.slice(token.range[0], token.range[1]);\n      next();\n      return finishNode(ast.literal(type, value, raw));\n    } else if (Keyword === type && 'function' === value) {\n      pushLocation(marker);\n      next();\n      if (options.scope) createScope();\n      return parseFunctionDeclaration(null);\n    } else if (consume('{')) {\n      pushLocation(marker);\n      return parseTableConstructor();\n    }\n  }\n\n  // Parser\n  // ------\n\n  // Export the main parser.\n  //\n  //   - `wait` Hold parsing until end() is called. Defaults to false\n  //   - `comments` Store comments. Defaults to true.\n  //   - `scope` Track identifier scope. Defaults to false.\n  //   - `locations` Store location information. Defaults to false.\n  //   - `ranges` Store the start and end character locations. Defaults to\n  //     false.\n  //   - `onCreateNode` Callback which will be invoked when a syntax node is\n  //     created.\n  //   - `onCreateScope` Callback which will be invoked when a new scope is\n  //     created.\n  //   - `onDestroyScope` Callback which will be invoked when the current scope\n  //     is destroyed.\n  //\n  // Example:\n  //\n  //     var parser = require('luaparser');\n  //     parser.parse('i = 0');\n\n  exports.parse = parse;\n\n  function parse(_input, _options) {\n    if ('undefined' === typeof _options && 'object' === typeof _input) {\n      _options = _input;\n      _input = undefined;\n    }\n    if (!_options) _options = {};\n\n    input = _input || '';\n    options = extend(defaultOptions, _options);\n\n    // Rewind the lexer\n    index = 0;\n    line = 1;\n    lineStart = 0;\n    length = input.length;\n    // When tracking identifier scope, initialize with an empty scope.\n    scopes = [[]];\n    scopeDepth = 0;\n    globals = [];\n    locations = [];\n\n    if (options.comments) comments = [];\n    if (!options.wait) return end();\n    return exports;\n  }\n\n  // Write to the source code buffer without beginning the parse.\n  exports.write = write;\n\n  function write(_input) {\n    input += String(_input);\n    length = input.length;\n    return exports;\n  }\n\n  // Send an EOF and begin parsing.\n  exports.end = end;\n\n  function end(_input) {\n    if ('undefined' !== typeof _input) write(_input);\n\n    // Ignore shebangs.\n    if (input && input.substr(0, 2) === '#!') input = input.replace(/^.*/, function (line) {\n      return line.replace(/./g, ' ');\n    });\n\n    length = input.length;\n    trackLocations = options.locations || options.ranges;\n    // Initialize with a lookahead token.\n    lookahead = lex();\n\n    var chunk = parseChunk();\n    if (options.comments) chunk.comments = comments;\n    if (options.scope) chunk.globals = globals;\n\n    if (locations.length > 0)\n      throw new Error('Location tracking failed. This is most likely a bug in luaparse');\n\n    return chunk;\n  }\n\n}));\n/* vim: set sw=2 ts=2 et tw=79 : */\n"],"sourceRoot":""}